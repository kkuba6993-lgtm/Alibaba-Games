<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Epic Drift Turbo v3</title>
<style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; background: #111; color: #fff; }
    canvas { display: block; margin: 0 auto; background: #222; }
    #hud { position: absolute; top: 10px; left: 10px; font-size: 24px; }
    #hud div { margin-bottom: 5px; }
</style>
</head>
<body>

<audio id="music" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" autoplay loop></audio>
<div id="hud">
    <div id="score">Punkty: 0</div>
    <div id="multiplier">Combo: x1</div>
    <div id="speed">Prędkość: 0</div>
    <div id="laps">Okreszenia: 0/10</div>
</div>
<canvas id="gameCanvas" width="1000" height="700"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let car = {
    x: 200,
    y: 150,
    width: 50,
    height: 30,
    angle: 0,
    speed: 0,
    maxSpeed: 3,
    accel: 0.15,
    friction: 0.05,
    turnSpeed: 4,
    drifting: false
};

let keys = {};
let score = 0;
let driftTimer = 0;
let combo = 0;
let lastDrift = false;
let laps = 0;
const totalLaps = 10;

document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

const scoreDiv = document.getElementById('score');
const speedDiv = document.getElementById('speed');
const multiplierDiv = document.getElementById('multiplier');
const lapsDiv = document.getElementById('laps');

// Szeroki tor (prostokąty)
const track = [
    {x: 100, y: 100, w: 800, h: 80},   // górna
    {x: 820, y: 100, w: 80, h: 500},   // prawa
    {x: 100, y: 520, w: 800, h: 80},   // dolna
    {x: 100, y: 100, w: 80, h: 500}    // lewa
];

// Punkt start/meta do liczenia okrążeń
const startLine = {x: 140, y: 100, w: 60, h: 10};
let passedStart = false;

function isOnTrack(x, y) {
    for (let t of track) {
        if (x >= t.x && x <= t.x+t.w && y >= t.y && y <= t.y+t.h) return true;
    }
    return false;
}

function isOnStartLine(x, y) {
    return x >= startLine.x && x <= startLine.x+startLine.w && y >= startLine.y && y <= startLine.y+startLine.h;
}

function update() {
    if (laps >= totalLaps) return; // Koniec gry

    // Sterowanie
    if (keys['ArrowUp']) car.speed += car.accel;
    else if (keys['ArrowDown']) car.speed -= car.accel;
    else {
        if (car.speed > 0) car.speed -= car.friction;
        if (car.speed < 0) car.speed += car.friction;
        if (Math.abs(car.speed) < car.friction) car.speed = 0;
    }

    let turning = false;
    if (keys['ArrowLeft']) { car.angle -= car.turnSpeed * Math.sign(car.speed); turning = true; }
    if (keys['ArrowRight']) { car.angle += car.turnSpeed * Math.sign(car.speed); turning = true; }

    // Drift detection
    if (turning && Math.abs(car.speed) > 2) {
        car.drifting = true;
        driftTimer++;
        combo++;
        score += Math.floor(driftTimer/5) * combo;
    } else {
        car.drifting = false;
        driftTimer = 0;
        if (lastDrift) combo = 0;
    }
    lastDrift = car.drifting;

    // Sprawdzenie toru
    if (!isOnTrack(car.x, car.y)) {
        car.speed *= 0.95;
        score -= 1;
        if (score < 0) score = 0;
    } else if (!car.drifting) {
        score -= 0.05;
        if (score < 0) score = 0;
    }

    // Limit prędkości
    if (car.speed > car.maxSpeed) car.speed = car.maxSpeed;
    if (car.speed < -car.maxSpeed) car.speed = -car.maxSpeed;

    // Ruch
    car.x += car.speed * Math.cos(car.angle*Math.PI/180);
    car.y += car.speed * Math.sin(car.angle*Math.PI/180);

    // Liczenie okrążeń
    if (isOnStartLine(car.x, car.y)) {
        if (!passedStart) {
            laps++;
            passedStart = true;
        }
    } else {
        passedStart = false;
    }

    // HUD
    scoreDiv.textContent = "Punkty: " + Math.floor(score);
    speedDiv.textContent = "Prędkość: " + Math.abs(car.speed).toFixed(1);
    multiplierDiv.textContent = "Combo: x" + combo;
    lapsDiv.textContent = "Okrążenia: " + laps + "/" + totalLaps;
}

function draw() {
    // Dynamiczne tło
    let gradient = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
    gradient.addColorStop(0, '#222');
    gradient.addColorStop(1, car.drifting ? '#ff0044' : '#444');
    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Tor
    ctx.fillStyle = '#555';
    for (let t of track) ctx.fillRect(t.x,t.y,t.w,t.h);

    // Start/meta
    ctx.fillStyle = 'white';
    ctx.fillRect(startLine.x, startLine.y, startLine.w, startLine.h);

    // Dym
    if (car.drifting) {
        for (let i=0;i<7;i++) {
            ctx.fillStyle = `rgba(200,200,200,${Math.random()})`;
            ctx.beginPath();
            ctx.arc(car.x - Math.cos(car.angle*Math.PI/180)*20 + (Math.random()-0.5)*30,
                    car.y - Math.sin(car.angle*Math.PI/180)*20 + (Math.random()-0.5)*30,
                    Math.random()*10,0,2*Math.PI);
            ctx.fill();
        }
    }

    // Auto
    ctx.save();
    ctx.translate(car.x,car.y);
    ctx.rotate(car.angle*Math.PI/180);
    ctx.fillStyle = car.drifting ? 'orange' : 'red';
    ctx.fillRect(-car.width/2,-car.height/2,car.width,car.height);
    // Przód
    ctx.beginPath();
    ctx.moveTo(car.width/2,0);
    ctx.lineTo(car.width/2-10,-10);
    ctx.lineTo(car.width/2-10,10);
    ctx.closePath();
    ctx.fillStyle = 'yellow';
    ctx.fill();
    ctx.restore();
}

function loop() {
    update();
    draw();
    if (laps < totalLaps) requestAnimationFrame(loop);
    else alert("Koniec gry! Punkty: " + Math.floor(score));
}

loop();
</script>

</body>
</html>
